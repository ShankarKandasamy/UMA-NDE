<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <title>UMA Viewer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;500;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a24;
            --accent: #00d4aa;
            --accent-dim: #00d4aa22;
            --text-primary: #f0f0f5;
            --text-secondary: #8888aa;
            --border: #2a2a3a;
            --success: #00d4aa;
            --error: #ff4466;
            --warning: #ffaa00;
        }

        body {
            font-family: 'Space Grotesk', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        /* Header */
        header {
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 1rem;
            color: var(--accent);
            letter-spacing: -0.5px;
            cursor: pointer;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }

        .status-dot.connected {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
            animation: pulse 2s infinite;
        }

        .status-dot.error {
            background: var(--error);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Tab Bar */
        .tab-bar {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .tab {
            flex: 1;
            padding: 0.75rem 1rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            transition: all 0.15s ease;
            border-bottom: 2px solid transparent;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .tab svg {
            width: 18px;
            height: 18px;
        }

        /* Main Layout */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        /* Browse Tab Layout */
        #browse-tab {
            display: none;
        }

        #browse-tab.active {
            display: flex;
        }

        .sidebar {
            width: 240px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 0.75rem 1rem;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border);
        }

        .folder-tree {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }

        .folder-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.15s ease;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .folder-item:hover {
            background: var(--bg-card);
        }

        .folder-item.active {
            background: var(--accent-dim);
            color: var(--accent);
        }

        .folder-item.nested {
            padding-left: 2rem;
        }

        .folder-item.nested-2 {
            padding-left: 3rem;
        }

        .folder-icon {
            width: 18px;
            height: 18px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .folder-item.active .folder-icon {
            color: var(--accent);
        }

        .folder-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .folder-count {
            font-size: 0.7rem;
            color: var(--text-secondary);
            background: var(--bg-card);
            padding: 2px 6px;
            border-radius: 10px;
        }

        .expand-icon {
            width: 16px;
            height: 16px;
            color: var(--text-secondary);
            transition: transform 0.15s ease;
        }

        .folder-item.expanded .expand-icon {
            transform: rotate(90deg);
        }

        .file-tree-item {
            display: flex;
            align-items: center;
            padding: 0.35rem 1rem 0.35rem 2.5rem;
            cursor: pointer;
            transition: background 0.15s ease;
            gap: 0.4rem;
            font-size: 0.78rem;
            color: var(--text-secondary);
        }

        .file-tree-item:hover {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .file-tree-item.active {
            background: var(--accent-dim);
            color: var(--accent);
        }

        .file-tree-item.nested-2 {
            padding-left: 3.5rem;
        }

        .folder-summary-badge {
            font-size: 0.6rem;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-weight: 600;
            line-height: 1;
        }

        .folder-summary-badge.generating {
            background: var(--warning);
            color: var(--bg-primary);
            animation: pulse-badge 1.2s ease-in-out infinite;
        }

        .folder-summary-badge.ready {
            background: var(--success);
            color: var(--bg-primary);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .folder-summary-badge.ready.fading {
            opacity: 0;
        }

        .folder-summary-badge.error {
            background: var(--error);
            color: var(--bg-primary);
        }

        @keyframes pulse-badge {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.85); }
        }

        .file-tree-item .file-tree-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }

        .file-tree-item .file-tree-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            z-index: 1000;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 4px 0;
            min-width: 160px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }
        .context-menu-item {
            padding: 8px 14px;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-primary);
            transition: background 0.15s;
        }
        .context-menu-item:hover {
            background: var(--accent);
            color: #fff;
        }
        .context-menu-item.danger {
            color: #ef4444;
        }
        .context-menu-item.danger:hover {
            background: #ef4444;
            color: #fff;
        }

        .inline-preview {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            padding: 1rem;
            overflow: hidden;
            min-height: 0;
        }

        .inline-preview img {
            max-width: 100%;
            flex: 1;
            min-height: 0;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .inline-preview iframe {
            width: 100%;
            flex: 1;
            min-height: 0;
            border: none;
            border-radius: 8px;
        }

        .inline-preview .preview-info {
            width: 100%;
            max-width: 400px;
        }

        .inline-preview .file-label {
            margin-top: 0.5rem;
            flex-shrink: 0;
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-align: center;
        }

        .inline-preview .user-notes {
            margin-top: 0.25rem;
            flex-shrink: 0;
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
            font-style: italic;
            max-width: 90%;
            word-break: break-word;
        }

        .inline-preview-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: var(--text-secondary);
            gap: 0.75rem;
        }

        .inline-preview-placeholder svg {
            width: 48px;
            height: 48px;
            opacity: 0.4;
        }

        .sidebar-footer {
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border);
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* File Grid Panel */
        .file-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .breadcrumb-bar {
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.85rem;
            overflow-x: auto;
        }

        .breadcrumb {
            color: var(--text-secondary);
            cursor: pointer;
            white-space: nowrap;
        }

        .breadcrumb:hover {
            color: var(--text-primary);
        }

        .breadcrumb.current {
            color: var(--text-primary);
            cursor: default;
        }

        .breadcrumb-sep {
            color: var(--text-secondary);
        }

        .file-toolbar {
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
        }

        .file-count {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .toolbar-actions {
            display: flex;
            gap: 0.5rem;
        }

        .toolbar-btn {
            padding: 0.4rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.15s ease;
        }

        .toolbar-btn:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .toolbar-btn svg {
            width: 14px;
            height: 14px;
        }

        .file-grid {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 1rem;
            align-content: start;
        }

        .file-grid:has(.inline-preview),
        .file-grid:has(.inline-preview-placeholder) {
            display: flex;
            flex-direction: column;
        }

        .file-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .file-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .file-thumb {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .file-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .file-thumb svg {
            width: 40px;
            height: 40px;
            color: var(--text-secondary);
        }

        .file-thumb.loading {
            background: linear-gradient(90deg, var(--bg-secondary) 25%, var(--bg-card) 50%, var(--bg-secondary) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        .file-name {
            font-size: 0.75rem;
            text-align: center;
            word-break: break-word;
            line-height: 1.3;
            max-height: 2.6em;
            overflow: hidden;
        }

        .file-meta {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        /* Empty State */
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .empty-state p {
            font-size: 0.85rem;
            text-align: center;
        }

        /* Gallery Tab */
        #gallery-tab {
            flex-direction: column;
        }

        .gallery-header {
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
        }

        .gallery-title {
            font-size: 1rem;
            font-weight: 500;
        }

        .gallery-filters {
            display: flex;
            gap: 0.5rem;
        }

        .filter-select {
            padding: 0.4rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .gallery-grid {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
            align-content: start;
        }

        .gallery-item {
            aspect-ratio: 1;
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            transition: transform 0.15s ease;
        }

        .gallery-item:hover {
            transform: scale(1.02);
        }

        .gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .gallery-item-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(transparent 60%, rgba(0, 0, 0, 0.7));
            opacity: 0;
            transition: opacity 0.15s ease;
            display: flex;
            align-items: flex-end;
            padding: 0.75rem;
        }

        .gallery-item:hover .gallery-item-overlay {
            opacity: 1;
        }

        .gallery-item-name {
            font-size: 0.75rem;
            color: white;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .gallery-footer {
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .gallery-count {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .load-more-btn {
            padding: 0.5rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .load-more-btn:hover {
            border-color: var(--accent);
        }

        /* Reports Tab */
        #reports-tab {
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .reports-placeholder {
            max-width: 400px;
            text-align: center;
        }

        .reports-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 1.5rem;
            background: var(--accent-dim);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reports-icon svg {
            width: 40px;
            height: 40px;
            color: var(--accent);
        }

        .reports-placeholder h2 {
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
        }

        .reports-placeholder p {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 1.5rem;
        }

        .reports-features {
            text-align: left;
            background: var(--bg-card);
            border-radius: 12px;
            padding: 1rem;
        }

        .reports-features li {
            padding: 0.5rem 0;
            color: var(--text-secondary);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .reports-features li svg {
            width: 16px;
            height: 16px;
            color: var(--accent);
        }

        /* Search Tab */
        #search-tab {
            flex-direction: column;
            padding: 0;
        }

        .search-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .search-input-row {
            display: flex;
            gap: 0.5rem;
        }

        .search-input {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            outline: none;
            transition: border-color 0.15s ease;
        }

        .search-input:focus {
            border-color: var(--accent);
        }

        .search-btn {
            padding: 0.75rem 1.25rem;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: var(--bg-primary);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            white-space: nowrap;
            transition: opacity 0.15s ease;
        }

        .search-btn:hover {
            opacity: 0.9;
        }

        .search-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .search-btn svg {
            width: 16px;
            height: 16px;
        }

        .search-progress {
            margin-top: 0.75rem;
            display: none;
        }

        .search-progress.active {
            display: block;
        }

        .search-progress-bar {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .search-stage {
            flex: 1;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            transition: background 0.3s ease;
        }

        .search-stage.active {
            background: var(--accent);
            animation: pulse 1.5s infinite;
        }

        .search-stage.done {
            background: var(--accent);
        }

        .search-progress-text {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .search-results {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .search-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            text-align: center;
            padding: 2rem;
        }

        .search-empty svg {
            width: 48px;
            height: 48px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .search-empty p {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .search-summary {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .search-result-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            transition: border-color 0.15s ease;
        }

        .search-result-card:hover {
            border-color: var(--accent);
        }

        .search-result-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
        }

        .search-result-file {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--accent);
        }

        .search-type-badge {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--accent-dim);
            color: var(--accent);
        }

        .search-type-badge.table {
            background: #ff884422;
            color: #ff8844;
        }

        .search-type-badge.chart {
            background: #4488ff22;
            color: #4488ff;
        }

        .search-type-badge.image {
            background: #aa44ff22;
            color: #aa44ff;
        }

        .search-type-badge.reading {
            background: #ffaa0022;
            color: #ffaa00;
        }

        .search-result-reason {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
            margin-bottom: 0.75rem;
        }

        .search-result-content {
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .search-result-content h4 {
            font-size: 0.85rem;
            color: var(--accent);
            margin-bottom: 0.4rem;
        }

        .search-result-content p {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .search-result-content pre {
            background: var(--bg-primary);
            padding: 0.5rem;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .search-result-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
            margin-top: 0.5rem;
        }

        .search-result-table th,
        .search-result-table td {
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--border);
            text-align: left;
        }

        .search-result-table th {
            background: var(--bg-secondary);
            font-weight: 600;
            color: var(--accent);
        }

        .search-result-table td {
            color: var(--text-primary);
        }

        .search-reading-card {
            display: inline-flex;
            align-items: baseline;
            gap: 0.4rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
        }

        .search-reading-param {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: capitalize;
        }

        .search-reading-value {
            font-size: 1.1rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
        }

        .search-reading-unit {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Preview Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .modal-overlay.active {
            display: flex;
        }

        .preview-modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .preview-header {
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
        }

        .preview-title {
            font-size: 0.9rem;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .preview-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        .preview-close:hover {
            color: var(--text-primary);
        }

        .preview-body {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            overflow: auto;
            min-height: 300px;
        }

        .preview-body img {
            max-width: 100%;
            max-height: 60vh;
            object-fit: contain;
            border-radius: 8px;
        }

        .preview-body iframe {
            width: 100%;
            height: 60vh;
            border: none;
            border-radius: 8px;
        }

        .preview-info {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 1rem;
        }

        .preview-info-row {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            font-size: 0.8rem;
        }

        .preview-info-label {
            color: var(--text-secondary);
        }

        .preview-notes {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
            text-align: center;
            border-top: 1px solid var(--border);
        }

        .preview-footer {
            padding: 1rem;
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            border-top: 1px solid var(--border);
        }

        .preview-btn {
            padding: 0.6rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .preview-btn:hover {
            border-color: var(--accent);
        }

        .preview-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-primary);
        }

        .preview-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Settings Modal */
        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: flex-end;
            justify-content: center;
            z-index: 200;
        }

        .settings-overlay.active {
            display: flex;
        }

        .settings-modal {
            background: var(--bg-secondary);
            border-radius: 20px 20px 0 0;
            width: 100%;
            max-width: 500px;
            padding: 1.5rem;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .settings-overlay.active .settings-modal {
            transform: translateY(0);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .settings-header h3 {
            font-size: 1.1rem;
        }

        .settings-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .setting-item {
            margin-bottom: 1rem;
        }

        .setting-item label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .setting-item input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .setting-item input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .save-settings-btn {
            width: 100%;
            padding: 0.875rem;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-weight: 600;
            cursor: pointer;
            margin-top: 1rem;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 0.75rem 1.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 300;
            font-size: 0.85rem;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--error);
        }

        .toast svg {
            width: 18px;
            height: 18px;
        }

        .toast.success svg {
            color: var(--success);
        }

        .toast.error svg {
            color: var(--error);
        }

        /* Loading Spinner */
        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Mobile sidebar toggle */
        .sidebar-toggle {
            display: none;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            margin-right: 0.5rem;
            flex-shrink: 0;
        }

        .sidebar-toggle svg {
            width: 20px;
            height: 20px;
        }

        .sidebar-close {
            display: none;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            margin-left: auto;
        }

        .sidebar-close svg {
            width: 18px;
            height: 18px;
        }

        .sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99;
        }

        .sidebar-overlay.open {
            display: block;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar-toggle {
                display: flex;
                align-items: center;
            }

            .sidebar-close {
                display: flex;
                align-items: center;
            }

            .sidebar {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                width: 280px;
                z-index: 100;
            }

            .sidebar.open {
                display: flex;
            }

            .sidebar-header {
                display: flex;
                align-items: center;
            }

            .file-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }

            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            }

            .preview-modal {
                width: 100%;
                height: 100%;
                max-width: none;
                max-height: none;
                border-radius: 0;
            }
        }
    </style>
</head>

<body>
    <!-- Header -->
    <header>
        <div class="logo" id="logo">UMA_VIEWER</div>
        <div class="header-right">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Connecting...</span>
            </div>
        </div>
    </header>

    <!-- Tab Bar -->
    <nav class="tab-bar">
        <button class="tab active" data-tab="browse">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />
            </svg>
            Browse
        </button>
        <button class="tab" data-tab="gallery">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                <circle cx="8.5" cy="8.5" r="1.5" />
                <polyline points="21 15 16 10 5 21" />
            </svg>
            Gallery
        </button>
        <button class="tab" data-tab="search">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round">
                <circle cx="11" cy="11" r="8" />
                <line x1="21" y1="21" x2="16.65" y2="16.65" />
            </svg>
            Search
        </button>
        <button class="tab" data-tab="reports">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                <polyline points="14 2 14 8 20 8" />
                <line x1="16" y1="13" x2="8" y2="13" />
                <line x1="16" y1="17" x2="8" y2="17" />
            </svg>
            Reports
        </button>
    </nav>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Browse Tab -->
        <section id="browse-tab" class="tab-content active">
            <!-- Sidebar overlay (mobile) -->
            <div class="sidebar-overlay" id="sidebarOverlay"></div>
            <!-- Sidebar -->
            <aside class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    Folders
                    <button class="sidebar-close" id="sidebarClose" aria-label="Close folders">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
                <div class="folder-tree" id="folderTree">
                    <!-- Populated by JavaScript -->
                </div>
                <div class="sidebar-footer" id="storageInfo">Loading...</div>
            </aside>

            <!-- File Panel -->
            <div class="file-panel">
                <div class="breadcrumb-bar" id="breadcrumbs">
                    <button class="sidebar-toggle" id="sidebarToggle" aria-label="Open folders">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="3" y1="12" x2="21" y2="12"/>
                            <line x1="3" y1="6" x2="21" y2="6"/>
                            <line x1="3" y1="18" x2="21" y2="18"/>
                        </svg>
                    </button>
                    <span class="breadcrumb current">Home</span>
                </div>
                <div class="file-toolbar">
                    <span class="file-count" id="fileCount">0 items</span>
                    <div class="toolbar-actions">
                        <button class="toolbar-btn" id="refreshBtn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="23 4 23 10 17 10" />
                                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10" />
                            </svg>
                            Refresh
                        </button>
                    </div>
                </div>
                <div class="file-grid" id="fileGrid">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
        </section>

        <!-- Gallery Tab -->
        <section id="gallery-tab" class="tab-content">
            <div class="gallery-header">
                <span class="gallery-title">Image Gallery</span>
                <div class="gallery-filters">
                    <select class="filter-select" id="galleryDateFilter">
                        <option value="">All Dates</option>
                    </select>
                </div>
            </div>
            <div class="gallery-grid" id="galleryGrid">
                <!-- Populated by JavaScript -->
            </div>
            <div class="gallery-footer">
                <span class="gallery-count" id="galleryCount">0 images</span>
                <button class="load-more-btn" id="loadMoreBtn" style="display: none;">Load More</button>
            </div>
        </section>

        <!-- Search Tab -->
        <section id="search-tab" class="tab-content">
            <div class="search-header">
                <div class="search-input-row">
                    <input type="text" class="search-input" id="searchInput"
                        placeholder="Ask a question about your documents...">
                    <button class="search-btn" id="searchBtn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8" />
                            <line x1="21" y1="21" x2="16.65" y2="16.65" />
                        </svg>
                        Search
                    </button>
                </div>
                <div class="search-progress" id="searchProgress">
                    <div class="search-progress-bar">
                        <div class="search-stage" id="searchStage1"></div>
                        <div class="search-stage" id="searchStage2"></div>
                        <div class="search-stage" id="searchStage3"></div>
                    </div>
                    <span class="search-progress-text" id="searchProgressText">Searching...</span>
                </div>
            </div>
            <div class="search-results" id="searchResults">
                <div class="search-empty">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8" />
                        <line x1="21" y1="21" x2="16.65" y2="16.65" />
                    </svg>
                    <p>Search across all your documents using AI.<br>Ask questions like "What are the calibration requirements?" or "Show me thickness readings."</p>
                </div>
            </div>
        </section>

        <!-- Reports Tab -->
        <section id="reports-tab" class="tab-content">
            <div class="reports-placeholder">
                <div class="reports-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                        <polyline points="14 2 14 8 20 8" />
                        <line x1="16" y1="13" x2="8" y2="13" />
                        <line x1="16" y1="17" x2="8" y2="17" />
                    </svg>
                </div>
                <h2>AI Reports</h2>
                <p>Generate AI-assisted inspection reports from your uploaded data. Coming soon.</p>
                <ul class="reports-features">
                    <li>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20 6 9 17 4 12" />
                        </svg>
                        Select inspection images and data
                    </li>
                    <li>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20 6 9 17 4 12" />
                        </svg>
                        Choose report templates (UT, MT/PT, Visual)
                    </li>
                    <li>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20 6 9 17 4 12" />
                        </svg>
                        Generate formatted inspection reports
                    </li>
                    <li>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20 6 9 17 4 12" />
                        </svg>
                        Export to PDF or Word format
                    </li>
                </ul>
            </div>
        </section>
    </div>

    <!-- Preview Modal -->
    <div class="modal-overlay" id="previewModal">
        <div class="preview-modal">
            <div class="preview-header">
                <span class="preview-title" id="previewTitle">File Preview</span>
                <button class="preview-close" id="previewClose">&times;</button>
            </div>
            <div class="preview-body" id="previewBody">
                <!-- Content loaded dynamically -->
            </div>
            <div class="preview-notes" id="previewNotes" style="display:none;"></div>
            <div class="preview-footer">
                <button class="preview-btn" id="previewDownload">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 10 12 15 17 10" />
                        <line x1="12" y1="15" x2="12" y2="3" />
                    </svg>
                    Download
                </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-overlay" id="settingsModal">
        <div class="settings-modal">
            <div class="settings-header">
                <h3>Settings</h3>
                <button class="settings-close" id="settingsClose">&times;</button>
            </div>
            <div class="setting-item">
                <label>API Endpoint</label>
                <input type="url" id="apiEndpoint" placeholder="https://your-worker.workers.dev">
            </div>
            <div class="setting-item">
                <label>API Key</label>
                <input type="password" id="apiKey" placeholder="Enter your API key">
            </div>
            <div class="setting-item">
                <label>Anthropic API Key</label>
                <input type="password" id="anthropicKey" placeholder="sk-ant-... (for Claude PDF extraction)">
            </div>
            <div class="setting-item">
                <label>OpenAI API Key</label>
                <input type="password" id="openaiKey" placeholder="sk-... (for search scoring)">
            </div>
            <button class="save-settings-btn" id="saveSettings">Save Settings</button>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="20 6 9 17 4 12" />
        </svg>
        <span id="toastMessage">Success</span>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu" style="display:none">
        <div class="context-menu-item" data-action="rename">Rename Folder</div>
        <div class="context-menu-item" data-action="move">Move to...</div>
        <div class="context-menu-item" data-action="new-folder">New Folder</div>
        <div class="context-menu-item danger" data-action="delete">Delete Folder</div>
    </div>

    <script src="prompts.js"></script>
    <script src="search.js"></script>
    <script>
        // ============================================
        // State Management
        // ============================================
        const state = {
            currentTab: 'browse',
            currentPath: [],
            folders: [],
            files: [],
            galleryImages: [],
            selectedFile: null,
            isLoading: false,
            isConnected: false,
            pollInterval: null,
            devFolders: [],       // Subfolders inside Development
            devExpanded: false,   // Whether Development folder is expanded in sidebar
            syncingToDev: false,  // Whether a Dev sync is currently in progress
            expandedFolders: {},    // Maps R2 folder path  fetched file list (expanded flag + cache)
            expandedDevFolders: {}, // Maps Dev subfolder name  file list (expanded flag + cache)
            selectedFileKey: null   // Tracks which file is selected for inline preview
        };

        // Track which R2 file keys have already been synced to Development
        const processedFileKeys = new Set(
            JSON.parse(localStorage.getItem('uma_processed_keys') || '[]')
        );

        function saveProcessedKeys() {
            localStorage.setItem('uma_processed_keys', JSON.stringify([...processedFileKeys]));
        }

        // ============================================
        // IndexedDB - Local Storage for Development
        // ============================================
        const DevDB = {
            DB_NAME: 'uma_development',
            DB_VERSION: 1,
            STORE_FILES: 'files',
            STORE_META: 'metadata',

            _db: null,

            async open() {
                if (this._db) return this._db;
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        // Store uploaded files: key = "subfolder/filename"
                        if (!db.objectStoreNames.contains(this.STORE_FILES)) {
                            db.createObjectStore(this.STORE_FILES, { keyPath: 'key' });
                        }
                        // Store extraction metadata: key = subfolder name
                        if (!db.objectStoreNames.contains(this.STORE_META)) {
                            db.createObjectStore(this.STORE_META, { keyPath: 'folder' });
                        }
                    };
                    req.onsuccess = (e) => {
                        this._db = e.target.result;
                        resolve(this._db);
                    };
                    req.onerror = (e) => reject(e.target.error);
                });
            },

            async listSubfolders() {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_FILES, 'readonly');
                    const store = tx.objectStore(this.STORE_FILES);
                    const req = store.getAllKeys();
                    req.onsuccess = () => {
                        const folders = new Set();
                        req.result.forEach(key => {
                            const parts = key.split('/');
                            if (parts.length > 1) folders.add(parts[0]);
                        });
                        resolve([...folders].sort());
                    };
                    req.onerror = (e) => reject(e.target.error);
                });
            },

            async listFiles(subfolder) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_FILES, 'readonly');
                    const store = tx.objectStore(this.STORE_FILES);
                    const req = store.getAll();
                    req.onsuccess = () => {
                        const prefix = subfolder ? subfolder + '/' : '';
                        const files = req.result.filter(f => {
                            if (!prefix) return true;
                            return f.key.startsWith(prefix);
                        });
                        resolve(files);
                    };
                    req.onerror = (e) => reject(e.target.error);
                });
            },

            async putFile(key, blob, originalName) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_FILES, 'readwrite');
                    const store = tx.objectStore(this.STORE_FILES);
                    store.put({
                        key,
                        blob,
                        originalName,
                        size: blob.size,
                        type: blob.type,
                        uploaded: new Date().toISOString()
                    });
                    tx.oncomplete = () => resolve();
                    tx.onerror = (e) => reject(e.target.error);
                });
            },

            async getFile(key) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_FILES, 'readonly');
                    const store = tx.objectStore(this.STORE_FILES);
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = (e) => reject(e.target.error);
                });
            },

            async deleteFile(key) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_FILES, 'readwrite');
                    const store = tx.objectStore(this.STORE_FILES);
                    store.delete(key);
                    tx.oncomplete = () => resolve();
                    tx.onerror = (e) => reject(e.target.error);
                });
            },

            async putMetadata(folder, data) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_META, 'readwrite');
                    const store = tx.objectStore(this.STORE_META);
                    const getReq = store.get(folder);
                    getReq.onsuccess = () => {
                        const existing = getReq.result || { folder };
                        const merged = { ...existing, ...data, folder, updated: new Date().toISOString() };
                        store.put(merged);
                    };
                    getReq.onerror = (e) => reject(e.target.error);
                    tx.oncomplete = () => resolve();
                    tx.onerror = (e) => reject(e.target.error);
                });
            },

            async getMetadata(folder) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.STORE_META, 'readonly');
                    const store = tx.objectStore(this.STORE_META);
                    const req = store.get(folder);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = (e) => reject(e.target.error);
                });
            }
        };

        // ============================================
        // LLM Extraction
        // ============================================
        // Prompts loaded from prompts.js: EXTRACTION_SYSTEM_MSG, PDF_EXTRACTION_PROMPT, IMAGE_EXTRACTION_PROMPT

        async function extractWithLLM(filename, blob) {
            if (!settings.anthropicKey) {
                console.warn('[LLM] No Anthropic API key configured, skipping extraction');
                return null;
            }
            if (!settings.apiEndpoint) {
                console.warn('[LLM] No API endpoint configured, skipping extraction (needed as Anthropic CORS proxy)');
                return null;
            }

            // Convert blob to base64
            const base64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const dataUrl = reader.result;
                    resolve(dataUrl.split(',')[1]);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });

            const isPdf = blob.type === 'application/pdf' || filename.toLowerCase().endsWith('.pdf');
            const contentBlock = isPdf
                ? { type: 'document', source: { type: 'base64', media_type: 'application/pdf', data: base64 } }
                : { type: 'image', source: { type: 'base64', media_type: blob.type || 'image/jpeg', data: base64 } };
            const promptText = isPdf ? PDF_EXTRACTION_PROMPT : IMAGE_EXTRACTION_PROMPT;

            const body = {
                model: 'claude-opus-4-5-20251101',
                max_tokens: 16384,
                system: EXTRACTION_SYSTEM_MSG,
                messages: [
                    {
                        role: 'user',
                        content: [
                            contentBlock,
                            { type: 'text', text: promptText }
                        ]
                    }
                ]
            };

            // Proxy through our Cloudflare Worker (Anthropic API doesn't support CORS)
            const proxyUrl = `${settings.apiEndpoint}/llm/anthropic`;

            const response = await fetch(proxyUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': settings.apiKey,
                    'X-Anthropic-Key': settings.anthropicKey
                },
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const errText = await response.text();
                throw new Error(`Anthropic API error ${response.status}: ${errText}`);
            }

            const data = await response.json();
            const rawText = data.content[0].text;

            // Log token usage
            if (data.usage) {
                console.log(`[LLM] Tokens  input: ${data.usage.input_tokens}, output: ${data.usage.output_tokens}`);
            }

            // Parse JSON, handling possible markdown fences
            try {
                return JSON.parse(rawText);
            } catch {
                let cleaned = rawText.trim();
                if (cleaned.startsWith('```')) {
                    cleaned = cleaned.split('\n').slice(1).join('\n');
                    cleaned = cleaned.replace(/```\s*$/, '');
                }
                return JSON.parse(cleaned);
            }
        }

        // ============================================
        // Folder Summary Generation
        // ============================================
        const folderSummaryTimers = {};
        const folderSummaryStates = {};

        function setFolderSummaryStatus(folderName, status) {
            folderSummaryStates[folderName] = status;
            // Update badge in sidebar without full re-render
            const badge = document.querySelector(`.folder-summary-badge[data-folder="${folderName}"]`);
            if (badge) {
                badge.className = `folder-summary-badge ${status}`;
                badge.textContent = status === 'generating' ? '' : status === 'ready' ? '\u2713' : '!';
                if (status === 'ready') {
                    setTimeout(() => {
                        badge.classList.add('fading');
                        setTimeout(() => { delete folderSummaryStates[folderName]; badge.remove(); }, 500);
                    }, 5000);
                }
            } else {
                // Badge not in DOM yet  trigger re-render so it appears
                renderFolderTree(state.folders);
            }
        }

        async function isFolderSummaryStale(folderName) {
            try {
                const files = await DevDB.listFiles(folderName);
                const realFiles = files
                    .filter(f => {
                        const name = f.key.split('/').pop();
                        return name !== '.folder' && !name.endsWith('_extraction.json');
                    })
                    .map(f => f.key.split('/').pop())
                    .sort();

                const meta = await DevDB.getMetadata(folderName);
                if (!meta || !meta.folderSummary) return true;

                const storedList = (meta.folderSummary.fileList || []).slice().sort();
                if (realFiles.length !== storedList.length) return true;
                return realFiles.some((f, i) => f !== storedList[i]);
            } catch (err) {
                console.warn(`[Folder Summary] Stale check failed for ${folderName}:`, err);
                return true;
            }
        }

        async function generateFolderSummary(folderName) {
            if (!settings.anthropicKey || !settings.apiEndpoint) {
                console.warn('[Folder Summary] No API key/endpoint configured, skipping');
                return;
            }

            console.log(`[Folder Summary] Generating for "${folderName}"...`);
            setFolderSummaryStatus(folderName, 'generating');

            try {
                // List real files in folder
                const files = await DevDB.listFiles(folderName);
                const realFiles = files.filter(f => {
                    const name = f.key.split('/').pop();
                    return name !== '.folder' && !name.endsWith('_extraction.json');
                });

                if (realFiles.length === 0) {
                    // Empty folder  clear summary
                    await DevDB.putMetadata(folderName, { folderSummary: null });
                    console.log(`[Folder Summary] Cleared summary for empty folder "${folderName}"`);
                    setFolderSummaryStatus(folderName, 'ready');
                    return;
                }

                // Collect extraction summaries
                const fileSummaries = [];
                const fileList = [];
                for (const file of realFiles) {
                    const fileName = file.key.split('/').pop();
                    fileList.push(fileName);

                    // Look for companion extraction JSON
                    const baseName = fileName.replace(/\.[^.]+$/, '');
                    const extKey = `${folderName}/${baseName}_extraction.json`;
                    try {
                        const extRecord = await DevDB.getFile(extKey);
                        if (extRecord && extRecord.blob) {
                            const text = await extRecord.blob.text();
                            const extraction = JSON.parse(text);
                            fileSummaries.push({
                                filename: fileName,
                                summary: extraction.summary || '',
                                keywords: extraction.keywords || []
                            });
                        }
                    } catch (_) {
                        // No extraction available  skip
                    }
                }

                if (fileSummaries.length === 0) {
                    console.log(`[Folder Summary] No extractions available yet for "${folderName}", skipping`);
                    delete folderSummaryStates[folderName];
                    return;
                }

                // Build user message
                let userMessage = `Folder: "${folderName}"\nFiles: ${fileSummaries.length}\n\n`;
                fileSummaries.forEach((f, i) => {
                    userMessage += `--- File ${i + 1}: ${f.filename} ---\nSummary: ${f.summary}\nKeywords: ${Array.isArray(f.keywords) ? f.keywords.join(', ') : f.keywords}\n\n`;
                });

                // Call Claude Sonnet via proxy
                const body = {
                    model: 'claude-sonnet-4-5-20250929',
                    max_tokens: 1024,
                    system: FOLDER_SUMMARY_SYSTEM_MSG,
                    messages: [{ role: 'user', content: userMessage + '\n\n' + FOLDER_SUMMARY_PROMPT }]
                };

                const response = await fetch(`${settings.apiEndpoint}/llm/anthropic`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': settings.apiKey,
                        'X-Anthropic-Key': settings.anthropicKey
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`API error ${response.status}: ${errText}`);
                }

                const data = await response.json();
                const rawText = data.content[0].text;

                if (data.usage) {
                    console.log(`[Folder Summary] Tokens  input: ${data.usage.input_tokens}, output: ${data.usage.output_tokens}`);
                }

                let result;
                try {
                    result = JSON.parse(rawText);
                } catch {
                    let cleaned = rawText.trim();
                    if (cleaned.startsWith('```')) {
                        cleaned = cleaned.split('\n').slice(1).join('\n').replace(/```\s*$/, '');
                    }
                    result = JSON.parse(cleaned);
                }

                // Save to metadata store
                await DevDB.putMetadata(folderName, {
                    folderSummary: {
                        summary: result.summary,
                        keywords: result.keywords,
                        fileCount: realFiles.length,
                        fileList: fileList.sort(),
                        generated: new Date().toISOString()
                    }
                });

                console.log(`[Folder Summary] Saved summary for "${folderName}" (${realFiles.length} files, ${result.keywords.length} keywords)`);
                setFolderSummaryStatus(folderName, 'ready');
            } catch (err) {
                console.error(`[Folder Summary] Generation failed for "${folderName}":`, err);
                setFolderSummaryStatus(folderName, 'error');
            }
        }

        function scheduleFolderSummary(folderName) {
            if (folderName === 'Uncategorized') return;

            console.log(`[Folder Summary] Scheduled regeneration for "${folderName}" in 7s`);

            if (folderSummaryTimers[folderName]) {
                clearTimeout(folderSummaryTimers[folderName]);
            }

            folderSummaryTimers[folderName] = setTimeout(async () => {
                delete folderSummaryTimers[folderName];
                try {
                    const stale = await isFolderSummaryStale(folderName);
                    if (stale) {
                        await generateFolderSummary(folderName);
                    } else {
                        console.log(`[Folder Summary] "${folderName}" is up-to-date, skipping`);
                    }
                } catch (err) {
                    console.error(`[Folder Summary] Error in scheduled task for "${folderName}":`, err);
                }
            }, 7000);
        }

        // Settings from localStorage
        const settings = {
            apiEndpoint: localStorage.getItem('uma_api_endpoint') || '',
            apiKey: localStorage.getItem('uma_api_key') || '',
            anthropicKey: localStorage.getItem('uma_anthropic_key') || '',
            openaiKey: localStorage.getItem('uma_openai_key') || ''
        };

        // ============================================
        // DOM Elements
        // ============================================
        const elements = {
            statusDot: document.getElementById('statusDot'),
            statusText: document.getElementById('statusText'),
            folderTree: document.getElementById('folderTree'),
            fileGrid: document.getElementById('fileGrid'),
            fileCount: document.getElementById('fileCount'),
            breadcrumbs: document.getElementById('breadcrumbs'),
            storageInfo: document.getElementById('storageInfo'),
            galleryGrid: document.getElementById('galleryGrid'),
            galleryCount: document.getElementById('galleryCount'),
            galleryDateFilter: document.getElementById('galleryDateFilter'),
            previewModal: document.getElementById('previewModal'),
            previewTitle: document.getElementById('previewTitle'),
            previewBody: document.getElementById('previewBody'),
            previewNotes: document.getElementById('previewNotes'),
            settingsModal: document.getElementById('settingsModal'),
            toast: document.getElementById('toast'),
            toastMessage: document.getElementById('toastMessage')
        };

        // ============================================
        // API Functions
        // ============================================
        async function api(endpoint, options = {}) {
            if (!settings.apiEndpoint || !settings.apiKey) {
                throw new Error('API not configured');
            }

            const url = `${settings.apiEndpoint}${endpoint}`;
            const response = await fetch(url, {
                ...options,
                headers: {
                    'X-API-Key': settings.apiKey,
                    ...options.headers
                }
            });

            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }

            // Check if response is JSON
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                return response.json();
            }

            return response;
        }

        async function checkConnection() {
            try {
                await api('/list?limit=1');
                setConnectionStatus(true);
                return true;
            } catch (error) {
                setConnectionStatus(false);
                return false;
            }
        }

        function setConnectionStatus(connected) {
            state.isConnected = connected;
            elements.statusDot.className = 'status-dot ' + (connected ? 'connected' : 'error');
            elements.statusText.textContent = connected ? 'Connected' : 'Offline';
        }

        // ============================================
        // Folder Tree Functions
        // ============================================
        async function loadFolderTree() {
            try {
                // Get top-level date folders
                const data = await api('/list?delimiter=/');
                const folders = data.folders || [];

                // Sort folders descending (newest first)
                folders.sort((a, b) => b.localeCompare(a));

                state.folders = folders;
                renderFolderTree(folders);

                // Calculate total storage
                const allFiles = await api('/list');
                const totalSize = (allFiles.objects || []).reduce((sum, obj) => sum + (obj.size || 0), 0);
                elements.storageInfo.textContent = `Storage: ${formatSize(totalSize)}`;

            } catch (error) {
                console.error('Failed to load folders:', error);
                // Still render folder tree with Development even if R2 fails
                state.folders = [];
                renderFolderTree([]);
            }
        }

        async function loadDevFolders() {
            try {
                state.devFolders = await DevDB.listSubfolders();
            } catch (error) {
                console.error('Failed to load dev folders:', error);
                state.devFolders = [];
            }
        }

        async function loadDevFiles(path) {
            try {
                state.isLoading = true;

                if (path.length === 1) {
                    // At Development root  show subfolders as folder cards
                    const subfolders = state.devFolders;
                    if (subfolders.length === 0) {
                        renderEmptyState('No projects yet');
                        return;
                    }

                    elements.fileCount.textContent = `${subfolders.length} project${subfolders.length !== 1 ? 's' : ''}`;
                    let html = '';
                    subfolders.forEach(sub => {
                        html += `
                            <div class="file-card" data-key="Development/${sub}" data-name="${sub}" data-dev-folder="true">
                                <div class="file-thumb">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                                    </svg>
                                </div>
                                <div class="file-name">${sub}</div>
                                <div class="file-meta">Project</div>
                            </div>
                        `;
                    });

                    elements.fileGrid.innerHTML = html;

                    // Click navigates into subfolder
                    elements.fileGrid.querySelectorAll('.file-card').forEach(card => {
                        card.addEventListener('click', () => {
                            const sub = card.dataset.name;
                            navigateToPath(['Development', sub]);
                        });
                    });
                } else {
                    // Inside a subfolder  show files from IndexedDB
                    const subfolder = path[1];
                    const files = await DevDB.listFiles(subfolder);

                    if (files.length === 0) {
                        renderEmptyState('No files in this project');
                        return;
                    }

                    // Convert to the same shape renderFileGrid expects
                    const objects = files.map(f => ({
                        key: f.key,
                        size: f.size,
                        uploaded: f.uploaded,
                        customMetadata: { originalName: f.originalName },
                        _local: true
                    }));

                    state.files = objects;
                    renderFileGrid(objects);
                }
            } catch (error) {
                console.error('Failed to load dev files:', error);
                renderEmptyState('Failed to load local files');
            } finally {
                state.isLoading = false;
            }
        }

        // ============================================
        // Auto-sync new R2 files to Development folder
        // ============================================
        async function syncNewFilesToDev(r2Files) {
            if (state.syncingToDev || !r2Files || r2Files.length === 0) return;

            // Find files not yet synced
            const newFiles = r2Files.filter(f => !processedFileKeys.has(f.key));
            if (newFiles.length === 0) return;

            state.syncingToDev = true;
            console.log(`[Dev Sync] Found ${newFiles.length} new file(s) to sync`);

            try {
                for (const file of newFiles) {
                    const originalName = file.customMetadata?.originalName || file.key.split('/').pop();
                    const uncategorizedKey = `Uncategorized/${originalName}`;

                    try {
                        // Fetch the file blob from R2
                        const fileUrl = `${settings.apiEndpoint}/file/${encodeURIComponent(file.key)}`;
                        const response = await fetch(fileUrl, {
                            headers: { 'X-API-Key': settings.apiKey }
                        });

                        if (!response.ok) {
                            console.warn(`[Dev Sync] Failed to fetch ${file.key}: ${response.status}`);
                            continue;
                        }

                        const blob = await response.blob();

                        // Store initially under Development/Uncategorized/{originalName}
                        await DevDB.putFile(uncategorizedKey, blob, originalName);

                        // Mark as processed
                        processedFileKeys.add(file.key);
                        console.log(`[Dev Sync] Synced: ${file.key}  Development/${uncategorizedKey}`);

                        // Trigger LLM extraction (async, non-blocking)  moves file to category folder on success
                        const isExtractable = /\.(pdf|jpg|jpeg|png|gif|webp|bmp|tiff|tif|heic|heif)$/i.test(originalName);
                        if (!isExtractable) {
                            console.log(`[Dev Sync] Skipping extraction for non-extractable file: ${originalName}`);
                        } else if (!settings.anthropicKey) {
                            console.warn(`[Dev Sync] Skipping extraction  no Anthropic API key configured`);
                            showToast('LLM extraction skipped  set Anthropic key in Settings', 'error');
                        }
                        if (isExtractable && settings.anthropicKey) {
                            const _fileName = originalName;
                            const _uncatKey = uncategorizedKey;
                            const _blob = blob;
                            (async () => {
                                try {
                                    showToast(`Extracting: ${_fileName}...`, 'success');
                                    console.log(`[LLM] Starting extraction for ${_fileName}`);
                                    const extraction = await extractWithLLM(_fileName, _blob);
                                    if (!extraction) {
                                        console.warn(`[LLM] Extraction returned null for ${_fileName}`);
                                    }
                                    if (extraction) {
                                        // Determine category folder from LLM result
                                        const category = (extraction.category && extraction.category.trim()) || 'Uncategorized';
                                        console.log(`[LLM] Category for ${_fileName}: "${category}" (raw: "${extraction.category}")`);
                                        const baseName = _fileName.replace(/\.[^.]+$/, '');
                                        const extractionName = `${baseName}_extraction.json`;
                                        const jsonBlob = new Blob(
                                            [JSON.stringify(extraction, null, 2)],
                                            { type: 'application/json' }
                                        );

                                        // Save extraction JSON under category folder
                                        await DevDB.putFile(`${category}/${extractionName}`, jsonBlob, extractionName);
                                        console.log(`[LLM] Extraction saved: ${category}/${extractionName}`);

                                        // Move original file from Uncategorized to category folder
                                        if (category !== 'Uncategorized') {
                                            await DevDB.putFile(`${category}/${_fileName}`, _blob, _fileName);
                                            await DevDB.deleteFile(_uncatKey);
                                            console.log(`[Dev Sync] Moved: ${_uncatKey}  ${category}/${_fileName}`);
                                        }

                                        showToast(`Extraction complete: ${_fileName}  ${category}`, 'success');

                                        // Schedule folder summary regeneration
                                        scheduleFolderSummary(category);

                                        // Refresh sidebar  clear cached expansion so folders re-fetch
                                        state.expandedDevFolders = {};
                                        await loadDevFolders();
                                        renderFolderTree(state.folders);
                                    }
                                } catch (err) {
                                    console.error(`[LLM] Extraction failed for ${_fileName}:`, err);
                                    showToast(`Extraction failed: ${_fileName}`, 'error');
                                }
                            })();
                        }
                    } catch (err) {
                        console.warn(`[Dev Sync] Error syncing ${file.key}:`, err);
                    }
                }

                // Persist processed keys
                saveProcessedKeys();

                // Refresh Development folder list in sidebar
                await loadDevFolders();
                renderFolderTree(state.folders);

                if (newFiles.length > 0) {
                    showToast(`${newFiles.length} file(s) synced to Development`, 'success');
                }
            } finally {
                state.syncingToDev = false;
            }
        }

        function renderFolderTree(folders) {
            // Add "Recent" at top
            let html = `
                <div class="folder-item ${state.currentPath.length === 0 ? 'active' : ''}" data-path="">
                    <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12 6 12 12 16 14"/>
                    </svg>
                    <span class="folder-name">Recent</span>
                </div>
            `;

            // Add date folders (from R2)  expandable inline tree
            folders.forEach(folder => {
                const folderName = folder.replace(/\/$/, '');
                const isActive = state.currentPath[0] === folderName;
                const isExpanded = state.expandedFolders.hasOwnProperty(folderName);
                html += `
                    <div class="folder-item ${isActive ? 'active' : ''} ${isExpanded ? 'expanded' : ''}" data-path="${folderName}" data-date-folder="true">
                        <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9 18 15 12 9 6"/>
                        </svg>
                        <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        </svg>
                        <span class="folder-name">${folderName}</span>
                    </div>
                `;
                // Render nested file items if this folder is expanded
                if (isExpanded && Array.isArray(state.expandedFolders[folderName])) {
                    state.expandedFolders[folderName].forEach(file => {
                        const fileName = file.customMetadata?.originalName || file.key.split('/').pop();
                        const isSelected = state.selectedFileKey === file.key;
                        html += `
                            <div class="file-tree-item ${isSelected ? 'active' : ''}" data-file-key="${file.key}" data-file-name="${fileName}">
                                <svg class="file-tree-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                    <polyline points="14 2 14 8 20 8"/>
                                </svg>
                                <span class="file-tree-name">${fileName}</span>
                            </div>
                        `;
                    });
                }
            });

            // Separator between R2 date folders and Development
            html += `<div style="border-top: 1px solid var(--border); margin: 0.25rem 0;"></div>`;

            // Add Development folder (local, expandable)
            const devActive = state.currentPath[0] === 'Development';
            html += `
                <div class="folder-item ${devActive && state.currentPath.length === 1 ? 'active' : ''} ${state.devExpanded ? 'expanded' : ''}" data-path="Development" data-dev="true">
                    <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="9 18 15 12 9 6"/>
                    </svg>
                    <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    </svg>
                    <span class="folder-name">Development</span>
                    <span class="folder-count">${state.devFolders.length}</span>
                </div>
            `;

            // Add Development subfolders if expanded
            if (state.devExpanded) {
                state.devFolders.forEach(sub => {
                    const subActive = devActive && state.currentPath[1] === sub;
                    const isSubExpanded = state.expandedDevFolders.hasOwnProperty(sub);
                    html += `
                        <div class="folder-item nested ${subActive ? 'active' : ''} ${isSubExpanded ? 'expanded' : ''}" data-path="Development/${sub}" data-dev="true" data-dev-sub="true">
                            <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="9 18 15 12 9 6"/>
                            </svg>
                            <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                            </svg>
                            <span class="folder-name">${sub}</span>
                            ${folderSummaryStates[sub] ? `<span class="folder-summary-badge ${folderSummaryStates[sub]}" data-folder="${sub}">${folderSummaryStates[sub] === 'generating' ? '' : folderSummaryStates[sub] === 'ready' ? '\u2713' : '!'}</span>` : ''}
                        </div>
                    `;
                    // Render nested file items if this dev subfolder is expanded
                    if (isSubExpanded && Array.isArray(state.expandedDevFolders[sub])) {
                        state.expandedDevFolders[sub].filter(f => f.key.split('/').pop() !== '.folder').forEach(file => {
                            const fileName = file.customMetadata?.originalName || file.key.split('/').pop();
                            const isSelected = state.selectedFileKey === file.key;
                            html += `
                                <div class="file-tree-item nested-2 ${isSelected ? 'active' : ''}" data-file-key="${file.key}" data-file-name="${fileName}" data-local="true">
                                    <svg class="file-tree-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                        <polyline points="14 2 14 8 20 8"/>
                                    </svg>
                                    <span class="file-tree-name">${fileName}</span>
                                </div>
                            `;
                        });
                        // Virtual _summary.md item
                        if (state.expandedDevFolders[sub]._summary) {
                            const summaryKey = `__summary__/${sub}`;
                            const isSummarySelected = state.selectedFileKey === summaryKey;
                            html += `
                                <div class="file-tree-item nested-2 ${isSummarySelected ? 'active' : ''}" data-file-key="${summaryKey}" data-file-name="_summary.md" data-virtual-summary="${sub}" style="opacity:0.7; font-style:italic">
                                    <svg class="file-tree-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                        <polyline points="14 2 14 8 20 8"/>
                                    </svg>
                                    <span class="file-tree-name">_summary.md</span>
                                </div>
                            `;
                        }
                    }
                });
            }

            elements.folderTree.innerHTML = html;

            // Add click handlers for folder items
            elements.folderTree.querySelectorAll('.folder-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const path = item.dataset.path;

                    // Handle Development folder expand/collapse
                    if (path === 'Development' && item.dataset.dev && !item.dataset.devSub) {
                        state.devExpanded = !state.devExpanded;
                        if (!state.devExpanded) {
                            state.expandedDevFolders = {};
                            state.selectedFileKey = null;
                        }
                        renderFolderTree(state.folders);
                        navigateToPath(['Development']);
                        return;
                    }

                    // Handle Development subfolder expand/collapse
                    if (item.dataset.devSub) {
                        const sub = path.split('/')[1];
                        toggleDevSubfolder(sub);
                        return;
                    }

                    // Handle other Development items
                    if (item.dataset.dev) {
                        navigateToPath(path.split('/'));
                        return;
                    }

                    // Handle date folder expand/collapse
                    if (item.dataset.dateFolder) {
                        toggleDateFolder(path);
                        return;
                    }

                    // Handle "Recent"  collapse all expanded folders
                    state.expandedFolders = {};
                    state.expandedDevFolders = {};
                    state.selectedFileKey = null;
                    navigateToPath(path ? [path] : []);
                    renderFolderTree(state.folders);
                });
            });

            // Add click handlers for file tree items
            elements.folderTree.querySelectorAll('.file-tree-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const fileKey = item.dataset.fileKey;
                    const fileName = item.dataset.fileName;
                    // Update active states in tree
                    elements.folderTree.querySelectorAll('.file-tree-item').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');
                    // Handle virtual summary click
                    if (item.dataset.virtualSummary) {
                        const sub = item.dataset.virtualSummary;
                        state.selectedFileKey = `__summary__/${sub}`;
                        renderFolderSummaryPreview(sub);
                        return;
                    }
                    const isLocal = item.dataset.local === 'true';
                    state.selectedFileKey = fileKey;
                    // Show inline preview in the right pane
                    if (isLocal) {
                        renderInlinePreviewLocal(fileKey, fileName);
                    } else {
                        renderInlinePreview(fileKey, fileName);
                    }
                });
            });

            // Context menu: right-click on Development root row
            elements.folderTree.querySelectorAll('.folder-item[data-dev="true"]:not([data-dev-sub])').forEach(item => {
                item.addEventListener('contextmenu', (e) => {
                    showContextMenu(e, 'dev-root', {});
                });
            });

            // Context menu: right-click on dev subfolder rows
            elements.folderTree.querySelectorAll('.folder-item[data-dev-sub]').forEach(item => {
                item.addEventListener('contextmenu', (e) => {
                    const sub = item.dataset.path.split('/')[1];
                    showContextMenu(e, 'folder', { name: sub });
                });
            });

            // Context menu: right-click on local file items
            elements.folderTree.querySelectorAll('.file-tree-item[data-local]:not([data-virtual-summary])').forEach(item => {
                item.addEventListener('contextmenu', (e) => {
                    showContextMenu(e, 'file', { key: item.dataset.fileKey, name: item.dataset.fileName });
                });
            });
        }

        async function toggleDateFolder(folderName) {
            if (state.expandedFolders.hasOwnProperty(folderName)) {
                // Collapse: remove from expanded
                delete state.expandedFolders[folderName];
                if (state.selectedFileKey && state.selectedFileKey.startsWith(folderName + '/')) {
                    state.selectedFileKey = null;
                }
            } else {
                // Collapse any other expanded folder (single-expand behavior)
                state.expandedFolders = {};
                state.selectedFileKey = null;
                // Fetch files for this folder
                try {
                    const data = await api(`/list?prefix=${encodeURIComponent(folderName + '/')}`);
                    const files = (data.objects || []).filter(obj => !obj.key.endsWith('_metadata.json'));
                    state.expandedFolders[folderName] = files;
                } catch (err) {
                    console.error('Failed to load folder files:', err);
                    state.expandedFolders[folderName] = [];
                }
            }
            // Update breadcrumbs and right pane
            state.currentPath = [folderName];
            renderBreadcrumbs([folderName]);
            renderFolderTree(state.folders);
            // Show placeholder or keep selection
            if (state.selectedFileKey) {
                const files = state.expandedFolders[folderName] || [];
                const file = files.find(f => f.key === state.selectedFileKey);
                if (file) {
                    const fileName = file.customMetadata?.originalName || file.key.split('/').pop();
                    renderInlinePreview(file.key, fileName);
                }
            } else if (state.expandedFolders.hasOwnProperty(folderName)) {
                renderSelectFilePlaceholder();
            } else {
                // Collapsed  show normal file grid
                loadFiles([folderName]);
            }
        }

        function renderSelectFilePlaceholder() {
            const count = Object.values(state.expandedFolders).flat().length;
            elements.fileCount.textContent = `${count} item${count !== 1 ? 's' : ''}`;
            elements.fileGrid.innerHTML = `
                <div class="inline-preview-placeholder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                    </svg>
                    <p>Select a file to preview</p>
                </div>
            `;
        }

        async function renderInlinePreview(fileKey, fileName) {
            const folderName = fileKey.split('/')[0];
            const files = state.expandedFolders[folderName] || [];
            const file = files.find(f => f.key === fileKey);
            elements.fileCount.textContent = fileName;

            // Update breadcrumbs to show folder > file
            renderBreadcrumbs([folderName, fileName]);

            const fileUrl = `${settings.apiEndpoint}/file/${encodeURIComponent(fileKey)}`;

            if (isImageFile(fileName)) {
                elements.fileGrid.innerHTML = `<div class="inline-preview"><div class="spinner"></div></div>`;
                try {
                    const res = await fetch(fileUrl, { headers: { 'X-API-Key': settings.apiKey } });
                    const blob = await res.blob();
                    let notes = file?.customMetadata?.notes || '';
                    if (!notes) {
                        try { notes = JSON.parse(res.headers.get('X-Custom-Metadata') || '{}').notes || ''; } catch {}
                    }
                    elements.fileGrid.innerHTML = `
                        <div class="inline-preview">
                            <img src="${URL.createObjectURL(blob)}" alt="${fileName}">
                            <div class="file-label">${fileName}${file ? '  ' + formatSize(file.size) : ''}</div>
                            ${notes ? `<div class="user-notes">${notes.replace(/</g, '&lt;')}</div>` : ''}
                        </div>
                    `;
                } catch {
                    elements.fileGrid.innerHTML = `<div class="inline-preview"><p>Failed to load image</p></div>`;
                }
            } else if (fileName.toLowerCase().endsWith('.pdf')) {
                elements.fileGrid.innerHTML = `<div class="inline-preview"><div class="spinner"></div></div>`;
                try {
                    const res = await fetch(fileUrl, { headers: { 'X-API-Key': settings.apiKey } });
                    const blob = await res.blob();
                    const blobUrl = URL.createObjectURL(blob);
                    let pdfNotes = file?.customMetadata?.notes || '';
                    if (!pdfNotes) {
                        try { pdfNotes = JSON.parse(res.headers.get('X-Custom-Metadata') || '{}').notes || ''; } catch {}
                    }
                    elements.fileGrid.innerHTML = `
                        <div class="inline-preview">
                            <iframe src="${blobUrl}"></iframe>
                            <div class="file-label">${fileName}</div>
                            ${pdfNotes ? `<div class="user-notes">${pdfNotes.replace(/</g, '&lt;')}</div>` : ''}
                        </div>
                    `;
                } catch {
                    elements.fileGrid.innerHTML = `<div class="inline-preview"><p>Failed to load PDF</p></div>`;
                }
            } else {
                const otherNotes = file?.customMetadata?.notes || '';
                elements.fileGrid.innerHTML = `
                    <div class="inline-preview">
                        <div class="preview-info">
                            <div class="preview-info-row">
                                <span class="preview-info-label">File Name</span>
                                <span>${fileName}</span>
                            </div>
                            <div class="preview-info-row">
                                <span class="preview-info-label">Type</span>
                                <span>${getFileType(fileName)}</span>
                            </div>
                            ${file ? `<div class="preview-info-row">
                                <span class="preview-info-label">Size</span>
                                <span>${formatSize(file.size)}</span>
                            </div>` : ''}
                            ${otherNotes ? `<div class="preview-info-row">
                                <span class="preview-info-label">Notes</span>
                                <span>${otherNotes.replace(/</g, '&lt;')}</span>
                            </div>` : ''}
                        </div>
                        <a href="${fileUrl}" target="_blank" rel="noopener" style="margin-top:1rem;padding:0.5rem 1.5rem;background:var(--accent);color:#000;border:none;border-radius:6px;cursor:pointer;font-family:inherit;font-weight:500;text-decoration:none;display:inline-block;">Download</a>
                    </div>
                `;
            }
        }

        async function toggleDevSubfolder(subName) {
            if (state.expandedDevFolders.hasOwnProperty(subName)) {
                // Collapse
                delete state.expandedDevFolders[subName];
                if (state.selectedFileKey && state.selectedFileKey.startsWith(subName + '/')) {
                    state.selectedFileKey = null;
                }
            } else {
                // Expand  fetch files from IndexedDB
                try {
                    const files = await DevDB.listFiles(subName);
                    state.expandedDevFolders[subName] = files.filter(f => f.key.split('/').pop() !== '.folder').map(f => ({
                        key: f.key,
                        size: f.size,
                        uploaded: f.uploaded,
                        customMetadata: { originalName: f.originalName },
                        _local: true
                    }));
                    const meta = await DevDB.getMetadata(subName);
                    state.expandedDevFolders[subName]._summary = meta?.folderSummary || null;
                } catch (err) {
                    console.error('Failed to load dev subfolder files:', err);
                    state.expandedDevFolders[subName] = [];
                }
            }
            state.currentPath = ['Development', subName];
            renderBreadcrumbs(['Development', subName]);
            renderFolderTree(state.folders);
            if (state.selectedFileKey) {
                const files = state.expandedDevFolders[subName] || [];
                const file = files.find(f => f.key === state.selectedFileKey);
                if (file) {
                    const fileName = file.customMetadata?.originalName || file.key.split('/').pop();
                    renderInlinePreviewLocal(file.key, fileName);
                }
            } else if (state.expandedDevFolders.hasOwnProperty(subName)) {
                renderSelectFilePlaceholder();
            } else {
                loadDevFiles(['Development', subName]);
            }
        }

        async function renderInlinePreviewLocal(fileKey, fileName) {
            const parts = fileKey.split('/');
            const subName = parts[0];
            renderBreadcrumbs(['Development', subName, fileName]);
            elements.fileCount.textContent = fileName;

            const record = await DevDB.getFile(fileKey);
            if (!record) {
                elements.fileGrid.innerHTML = '<div class="inline-preview"><p>File not found</p></div>';
                return;
            }
            const blobUrl = URL.createObjectURL(record.blob);

            if (isImageFile(fileName)) {
                elements.fileGrid.innerHTML = `
                    <div class="inline-preview">
                        <img src="${blobUrl}" alt="${fileName}">
                        <div class="file-label">${fileName}  ${formatSize(record.size)}</div>
                    </div>
                `;
            } else if (fileName.toLowerCase().endsWith('.pdf')) {
                elements.fileGrid.innerHTML = `
                    <div class="inline-preview">
                        <iframe src="${blobUrl}"></iframe>
                        <div class="file-label">${fileName}</div>
                    </div>
                `;
            } else if (fileName.toLowerCase().endsWith('.json')) {
                try {
                    const text = await record.blob.text();
                    const formatted = JSON.stringify(JSON.parse(text), null, 2);
                    elements.fileGrid.innerHTML = `
                        <div class="inline-preview">
                            <pre style="padding:1rem;overflow:auto;font-size:0.8rem;color:var(--text-primary);font-family:'JetBrains Mono',monospace;white-space:pre-wrap;word-break:break-word;max-width:100%;width:100%;">${formatted.replace(/</g, '&lt;')}</pre>
                        </div>
                    `;
                } catch {
                    const text = await record.blob.text();
                    elements.fileGrid.innerHTML = `
                        <div class="inline-preview">
                            <pre style="padding:1rem;overflow:auto;font-size:0.8rem;color:var(--text-primary);white-space:pre-wrap;">${text.replace(/</g, '&lt;')}</pre>
                        </div>
                    `;
                }
            } else {
                elements.fileGrid.innerHTML = `
                    <div class="inline-preview">
                        <div class="preview-info">
                            <div class="preview-info-row">
                                <span class="preview-info-label">File Name</span>
                                <span>${fileName}</span>
                            </div>
                            <div class="preview-info-row">
                                <span class="preview-info-label">Type</span>
                                <span>${getFileType(fileName)}</span>
                            </div>
                            <div class="preview-info-row">
                                <span class="preview-info-label">Size</span>
                                <span>${formatSize(record.size)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        async function renderFolderSummaryPreview(subName) {
            renderBreadcrumbs(['Development', subName, '_summary.md']);
            elements.fileCount.textContent = '_summary.md';
            const meta = await DevDB.getMetadata(subName);
            if (!meta?.folderSummary) {
                elements.fileGrid.innerHTML = '<div class="inline-preview"><p>No summary available yet.</p></div>';
                return;
            }
            const s = meta.folderSummary;
            const esc = (str) => String(str || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            const keywordsHtml = (s.keywords || []).map(k => `<code style="background:var(--bg-tertiary);padding:0.1rem 0.4rem;border-radius:4px;font-size:0.8rem;">${esc(k)}</code>`).join(' ');
            const ts = s.generatedAt ? new Date(s.generatedAt).toLocaleString() : 'unknown';
            elements.fileGrid.innerHTML = `
                <div class="inline-preview" style="padding:1.5rem;">
                    <h3 style="margin:0 0 1rem 0;color:var(--text-primary);">${esc(subName)}  Folder Summary</h3>
                    <p style="color:var(--text-secondary);line-height:1.6;white-space:pre-wrap;">${esc(s.summary)}</p>
                    ${keywordsHtml ? `<div style="margin-top:1rem;"><strong style="color:var(--text-primary);">Keywords:</strong> ${keywordsHtml}</div>` : ''}
                    <div style="margin-top:1rem;color:var(--text-tertiary);font-size:0.8rem;">
                        ${s.fileCount ? `${s.fileCount} files` : ''} ${s.fileCount ? '' : ''} Generated ${ts}
                    </div>
                </div>
            `;
        }

        // ============================================
        // File Grid Functions
        // ============================================
        async function loadFiles(path = []) {
            try {
                state.isLoading = true;
                const prefix = path.length > 0 ? path.join('/') + '/' : '';

                const data = await api(`/list?prefix=${encodeURIComponent(prefix)}`);

                // Filter out metadata files and separate folders/files
                const objects = (data.objects || []).filter(obj => !obj.key.endsWith('_metadata.json'));

                // If at root (Recent), sort by upload time
                if (path.length === 0) {
                    objects.sort((a, b) => new Date(b.uploaded) - new Date(a.uploaded));
                }

                state.files = objects;
                renderFileGrid(objects);

            } catch (error) {
                console.error('Failed to load files:', error);
                renderEmptyState('Failed to load files');
            } finally {
                state.isLoading = false;
            }
        }

        function renderFileGrid(files) {
            if (files.length === 0) {
                renderEmptyState('No files found');
                return;
            }

            elements.fileCount.textContent = `${files.length} item${files.length !== 1 ? 's' : ''}`;

            let html = '';
            const isLocal = files.length > 0 && files[0]._local;

            files.forEach(file => {
                const fileName = file.customMetadata?.originalName || file.key.split('/').pop();
                const isImage = isImageFile(fileName);
                const fileUrl = isLocal ? '' : `${settings.apiEndpoint}/file/${encodeURIComponent(file.key)}`;

                html += `
                    <div class="file-card" data-key="${file.key}" data-name="${fileName}" ${isLocal ? 'data-local="true"' : ''}>
                        <div class="file-thumb ${isImage && !isLocal ? 'loading' : ''}">
                            ${isImage && !isLocal
                        ? `<img data-src="${fileUrl}" alt="${fileName}" onload="this.parentElement.classList.remove('loading')">`
                        : getFileIcon(fileName)
                    }
                        </div>
                        <div class="file-name">${fileName}</div>
                        <div class="file-meta">${formatSize(file.size)}</div>
                    </div>
                `;
            });

            elements.fileGrid.innerHTML = html;

            // Lazy load images (only for remote files)
            if (!isLocal) lazyLoadImages();

            // Add click handlers
            elements.fileGrid.querySelectorAll('.file-card').forEach(card => {
                card.addEventListener('click', () => {
                    const isLocalFile = card.dataset.local === 'true';
                    openPreview(card.dataset.key, card.dataset.name, isLocalFile);
                });
            });
        }

        function renderEmptyState(message) {
            elements.fileCount.textContent = '0 items';
            elements.fileGrid.innerHTML = `
                <div class="empty-state">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    </svg>
                    <h3>Empty</h3>
                    <p>${message}</p>
                </div>
            `;
        }

        function lazyLoadImages() {
            const images = elements.fileGrid.querySelectorAll('img[data-src]');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        // Add API key to image request via fetch
                        fetch(img.dataset.src, {
                            headers: { 'X-API-Key': settings.apiKey }
                        })
                            .then(res => res.blob())
                            .then(blob => {
                                img.src = URL.createObjectURL(blob);
                            })
                            .catch(() => {
                                img.parentElement.innerHTML = getFileIcon('error.img');
                                img.parentElement.classList.remove('loading');
                            });
                        observer.unobserve(img);
                    }
                });
            }, { rootMargin: '100px' });

            images.forEach(img => observer.observe(img));
        }

        // ============================================
        // Navigation Functions
        // ============================================
        function navigateToPath(path) {
            state.currentPath = path;
            renderBreadcrumbs(path);

            // Route to local DB or R2 API
            if (path[0] === 'Development') {
                loadDevFiles(path);
            } else {
                loadFiles(path);
            }

            // Update active folder in tree
            elements.folderTree.querySelectorAll('.folder-item').forEach(item => {
                const itemPath = item.dataset.path;
                const currentFullPath = path.join('/');
                item.classList.toggle('active', itemPath === currentFullPath || (!currentFullPath && !itemPath));
            });
        }

        function renderBreadcrumbs(path) {
            let html = '<span class="breadcrumb" data-path="">Home</span>';

            path.forEach((segment, index) => {
                html += '<span class="breadcrumb-sep">/</span>';
                const isLast = index === path.length - 1;
                const pathToHere = path.slice(0, index + 1).join('/');
                html += `<span class="breadcrumb ${isLast ? 'current' : ''}" data-path="${pathToHere}">${segment}</span>`;
            });

            elements.breadcrumbs.innerHTML = html;

            // Add click handlers
            elements.breadcrumbs.querySelectorAll('.breadcrumb:not(.current)').forEach(crumb => {
                crumb.addEventListener('click', () => {
                    const pathStr = crumb.dataset.path;
                    navigateToPath(pathStr ? pathStr.split('/') : []);
                });
            });
        }

        // ============================================
        // Gallery Functions
        // ============================================
        async function loadGallery() {
            try {
                const data = await api('/list');
                const images = (data.objects || [])
                    .filter(obj => isImageFile(obj.key) && !obj.key.endsWith('_metadata.json'))
                    .sort((a, b) => new Date(b.uploaded) - new Date(a.uploaded));

                state.galleryImages = images;

                // Populate date filter
                const dates = [...new Set(images.map(img => img.key.split('/')[0]))];
                elements.galleryDateFilter.innerHTML = '<option value="">All Dates</option>' +
                    dates.map(d => `<option value="${d}">${d}</option>`).join('');

                renderGallery(images);
            } catch (error) {
                console.error('Failed to load gallery:', error);
            }
        }

        function renderGallery(images) {
            elements.galleryCount.textContent = `${images.length} image${images.length !== 1 ? 's' : ''}`;

            if (images.length === 0) {
                elements.galleryGrid.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <polyline points="21 15 16 10 5 21"/>
                        </svg>
                        <h3>No Images</h3>
                        <p>Upload images via UMA Capture</p>
                    </div>
                `;
                return;
            }

            let html = '';
            images.forEach(img => {
                const fileName = img.customMetadata?.originalName || img.key.split('/').pop();
                const fileUrl = `${settings.apiEndpoint}/file/${encodeURIComponent(img.key)}`;

                html += `
                    <div class="gallery-item" data-key="${img.key}" data-name="${fileName}">
                        <img data-src="${fileUrl}" alt="${fileName}">
                        <div class="gallery-item-overlay">
                            <span class="gallery-item-name">${fileName}</span>
                        </div>
                    </div>
                `;
            });

            elements.galleryGrid.innerHTML = html;

            // Lazy load images
            const galleryImages = elements.galleryGrid.querySelectorAll('img[data-src]');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        fetch(img.dataset.src, {
                            headers: { 'X-API-Key': settings.apiKey }
                        })
                            .then(res => res.blob())
                            .then(blob => {
                                img.src = URL.createObjectURL(blob);
                            });
                        observer.unobserve(img);
                    }
                });
            }, { rootMargin: '100px' });

            galleryImages.forEach(img => observer.observe(img));

            // Add click handlers
            elements.galleryGrid.querySelectorAll('.gallery-item').forEach(item => {
                item.addEventListener('click', () => openPreview(item.dataset.key, item.dataset.name));
            });
        }

        // ============================================
        // Preview Modal
        // ============================================
        async function openPreview(fileKey, fileName, isLocal = false) {
            state.selectedFile = { key: fileKey, name: fileName, local: isLocal };
            elements.previewTitle.textContent = fileName;

            // Look up notes from file metadata across all state collections
            let fileNotes = '';
            if (!isLocal) {
                const folderName = fileKey.split('/')[0];
                const folderFiles = state.expandedFolders[folderName] || [];
                const fileMeta = folderFiles.find(f => f.key === fileKey)
                    || (state.files || []).find(f => f.key === fileKey)
                    || (state.galleryImages || []).find(f => f.key === fileKey);
                fileNotes = fileMeta?.customMetadata?.notes || '';
            }
            if (fileNotes) {
                elements.previewNotes.textContent = fileNotes;
                elements.previewNotes.style.display = '';
            } else {
                elements.previewNotes.textContent = '';
                elements.previewNotes.style.display = 'none';
            }

            if (isLocal) {
                // Load from IndexedDB
                const record = await DevDB.getFile(fileKey);
                if (!record) {
                    elements.previewBody.innerHTML = '<div class="empty-state"><p>File not found</p></div>';
                    elements.previewModal.classList.add('active');
                    return;
                }
                const blobUrl = URL.createObjectURL(record.blob);

                if (isImageFile(fileName)) {
                    elements.previewBody.innerHTML = `<img src="${blobUrl}" alt="${fileName}">`;
                } else if (fileName.toLowerCase().endsWith('.pdf')) {
                    elements.previewBody.innerHTML = `<iframe src="${blobUrl}"></iframe>`;
                } else if (fileName.toLowerCase().endsWith('.json')) {
                    const text = await record.blob.text();
                    try {
                        const formatted = JSON.stringify(JSON.parse(text), null, 2);
                        elements.previewBody.innerHTML = `<pre style="padding:1rem;overflow:auto;font-size:0.8rem;color:var(--text-primary);font-family:'JetBrains Mono',monospace;white-space:pre-wrap;word-break:break-word;">${formatted.replace(/</g, '&lt;')}</pre>`;
                    } catch {
                        elements.previewBody.innerHTML = `<pre style="padding:1rem;overflow:auto;font-size:0.8rem;color:var(--text-primary);">${text.replace(/</g, '&lt;')}</pre>`;
                    }
                } else {
                    elements.previewBody.innerHTML = `
                        <div class="preview-info">
                            <div class="preview-info-row">
                                <span class="preview-info-label">File Name</span>
                                <span>${fileName}</span>
                            </div>
                            <div class="preview-info-row">
                                <span class="preview-info-label">Type</span>
                                <span>${getFileType(fileName)}</span>
                            </div>
                            <div class="preview-info-row">
                                <span class="preview-info-label">Size</span>
                                <span>${formatSize(record.size)}</span>
                            </div>
                        </div>
                    `;
                }
            } else {
                const fileUrl = `${settings.apiEndpoint}/file/${encodeURIComponent(fileKey)}`;

                const updateNotesFromResponse = (res) => {
                    if (!fileNotes) {
                        try {
                            const meta = JSON.parse(res.headers.get('X-Custom-Metadata') || '{}');
                            if (meta.notes) {
                                elements.previewNotes.textContent = meta.notes;
                                elements.previewNotes.style.display = '';
                            }
                        } catch {}
                    }
                    return res;
                };

                if (isImageFile(fileName)) {
                    elements.previewBody.innerHTML = '<div class="spinner"></div>';
                    fetch(fileUrl, { headers: { 'X-API-Key': settings.apiKey } })
                        .then(updateNotesFromResponse)
                        .then(res => res.blob())
                        .then(blob => {
                            elements.previewBody.innerHTML = `<img src="${URL.createObjectURL(blob)}" alt="${fileName}">`;
                        });
                } else if (fileName.toLowerCase().endsWith('.pdf')) {
                    elements.previewBody.innerHTML = '<div class="spinner"></div>';
                    fetch(fileUrl, { headers: { 'X-API-Key': settings.apiKey } })
                        .then(updateNotesFromResponse)
                        .then(res => res.blob())
                        .then(blob => {
                            elements.previewBody.innerHTML = `<iframe src="${URL.createObjectURL(blob)}"></iframe>`;
                        });
                } else {
                    elements.previewBody.innerHTML = `
                        <div class="preview-info">
                            <div class="preview-info-row">
                                <span class="preview-info-label">File Name</span>
                                <span>${fileName}</span>
                            </div>
                            <div class="preview-info-row">
                                <span class="preview-info-label">Type</span>
                                <span>${getFileType(fileName)}</span>
                            </div>
                        </div>
                    `;
                }
            }

            elements.previewModal.classList.add('active');
        }

        function closePreview() {
            elements.previewModal.classList.remove('active');
            elements.previewNotes.style.display = 'none';
            elements.previewNotes.textContent = '';
            state.selectedFile = null;
        }

        async function downloadFile() {
            if (!state.selectedFile) return;

            try {
                let blob;
                if (state.selectedFile.local) {
                    const record = await DevDB.getFile(state.selectedFile.key);
                    if (!record) throw new Error('File not found');
                    blob = record.blob;
                } else {
                    const fileUrl = `${settings.apiEndpoint}/file/${encodeURIComponent(state.selectedFile.key)}`;
                    const response = await fetch(fileUrl, {
                        headers: { 'X-API-Key': settings.apiKey }
                    });
                    blob = await response.blob();
                }

                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = state.selectedFile.name;
                link.click();

                showToast('Download started', 'success');
            } catch (error) {
                showToast('Download failed', 'error');
            }
        }

        // ============================================
        // Settings Modal
        // ============================================
        function openSettings() {
            document.getElementById('apiEndpoint').value = settings.apiEndpoint;
            document.getElementById('apiKey').value = settings.apiKey;
            document.getElementById('anthropicKey').value = settings.anthropicKey;
            document.getElementById('openaiKey').value = settings.openaiKey;
            elements.settingsModal.classList.add('active');
        }

        function closeSettings() {
            elements.settingsModal.classList.remove('active');
        }

        function saveSettings() {
            settings.apiEndpoint = document.getElementById('apiEndpoint').value.replace(/\/$/, '');
            settings.apiKey = document.getElementById('apiKey').value;
            settings.anthropicKey = document.getElementById('anthropicKey').value;
            settings.openaiKey = document.getElementById('openaiKey').value;

            localStorage.setItem('uma_api_endpoint', settings.apiEndpoint);
            localStorage.setItem('uma_api_key', settings.apiKey);
            localStorage.setItem('uma_anthropic_key', settings.anthropicKey);
            localStorage.setItem('uma_openai_key', settings.openaiKey);

            closeSettings();
            showToast('Settings saved', 'success');

            // Reconnect
            init();
        }

        // ============================================
        // Tab Navigation
        // ============================================
        function switchTab(tabName) {
            state.currentTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.id === `${tabName}-tab`);
            });

            // Load tab data
            if (tabName === 'gallery' && state.galleryImages.length === 0) {
                loadGallery();
            }
        }

        // ============================================
        // Polling
        // ============================================
        function startPolling() {
            if (state.pollInterval) return;

            state.pollInterval = setInterval(async () => {
                if (state.currentTab === 'browse' && state.currentPath.length === 0) {
                    // Refresh Recent view
                    await loadFiles([]);
                }

                // Check for new files to sync to Development (runs regardless of current view)
                try {
                    const data = await api('/list');
                    const allFiles = (data.objects || []).filter(obj => !obj.key.endsWith('_metadata.json'));
                    syncNewFilesToDev(allFiles);
                } catch (err) {
                    // Silently ignore sync errors during polling
                }
            }, 10000);
        }

        function stopPolling() {
            if (state.pollInterval) {
                clearInterval(state.pollInterval);
                state.pollInterval = null;
            }
        }

        // ============================================
        // Utility Functions
        // ============================================
        function isImageFile(filename) {
            return /\.(jpg|jpeg|png|gif|webp|bmp)$/i.test(filename);
        }

        function getFileType(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const types = {
                pdf: 'PDF Document',
                doc: 'Word Document',
                docx: 'Word Document',
                xls: 'Excel Spreadsheet',
                xlsx: 'Excel Spreadsheet',
                csv: 'CSV Data',
                txt: 'Text File',
                json: 'JSON Data'
            };
            return types[ext] || ext.toUpperCase() + ' File';
        }

        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();

            if (['pdf'].includes(ext)) {
                return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <path d="M9 15h2v2H9zM13 15h2v2h-2z"/>
                </svg>`;
            }

            if (['xls', 'xlsx', 'csv'].includes(ext)) {
                return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="8" y1="13" x2="16" y2="13"/>
                    <line x1="8" y1="17" x2="16" y2="17"/>
                </svg>`;
            }

            return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
            </svg>`;
        }

        function formatSize(bytes) {
            if (!bytes) return '0 B';
            const units = ['B', 'KB', 'MB', 'GB'];
            let i = 0;
            while (bytes >= 1024 && i < units.length - 1) {
                bytes /= 1024;
                i++;
            }
            return `${bytes.toFixed(i > 0 ? 1 : 0)} ${units[i]}`;
        }

        // ============================================
        // Context Menu & Folder Operations
        // ============================================
        let contextMenuTarget = null; // { type: 'folder'|'file', name: string, key: string }

        function showContextMenu(e, targetType, targetData) {
            e.preventDefault();
            e.stopPropagation();
            contextMenuTarget = { type: targetType, ...targetData };
            const menu = document.getElementById('contextMenu');
            // Show/hide items based on target type
            menu.querySelector('[data-action="rename"]').style.display = targetType === 'folder' ? '' : 'none';
            menu.querySelector('[data-action="move"]').style.display = targetType === 'file' ? '' : 'none';
            menu.querySelector('[data-action="new-folder"]').style.display = targetType === 'dev-root' ? '' : 'none';
            menu.querySelector('[data-action="delete"]').style.display = targetType === 'folder' ? '' : 'none';
            menu.style.display = 'block';
            // Position at cursor, clamped to viewport
            const x = Math.min(e.clientX, window.innerWidth - 180);
            const y = Math.min(e.clientY, window.innerHeight - menu.offsetHeight - 10);
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
            contextMenuTarget = null;
        }

        document.addEventListener('click', hideContextMenu);
        document.addEventListener('contextmenu', (e) => {
            if (!e.target.closest('.context-menu')) hideContextMenu();
        });

        // Wire context menu item clicks
        document.getElementById('contextMenu').addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (!action || !contextMenuTarget) return;
            const target = contextMenuTarget;
            hideContextMenu();
            switch (action) {
                case 'rename': renameDevFolder(target.name); break;
                case 'move': moveDevFile(target.key); break;
                case 'new-folder': createDevFolder(); break;
                case 'delete': deleteDevFolder(target.name); break;
            }
        });

        async function renameDevFolder(oldName) {
            const newName = prompt('Rename folder:', oldName);
            if (!newName || newName === oldName) return;
            if (newName.includes('/')) { showToast('Folder name cannot contain "/"', 'error'); return; }
            if (state.devFolders.includes(newName)) { showToast('A folder with that name already exists', 'error'); return; }
            try {
                const files = await DevDB.listFiles(oldName);
                for (const file of files) {
                    const record = await DevDB.getFile(file.key);
                    const filename = file.key.split('/').slice(1).join('/');
                    await DevDB.putFile(newName + '/' + filename, record.blob, record.originalName);
                    await DevDB.deleteFile(file.key);
                }
                // Update expanded cache
                if (state.expandedDevFolders.hasOwnProperty(oldName)) {
                    state.expandedDevFolders[newName] = state.expandedDevFolders[oldName].map(f => ({
                        ...f,
                        key: newName + '/' + f.key.split('/').slice(1).join('/')
                    }));
                    delete state.expandedDevFolders[oldName];
                }
                if (state.currentPath[1] === oldName) {
                    state.currentPath[1] = newName;
                }
                await loadDevFolders();
                renderFolderTree(state.folders);
                showToast('Renamed to ' + newName);
            } catch (err) {
                console.error('Rename failed:', err);
                showToast('Rename failed', 'error');
            }
        }

        async function moveDevFile(fileKey) {
            const currentFolder = fileKey.split('/')[0];
            const targets = state.devFolders.filter(f => f !== currentFolder);
            if (targets.length === 0) { showToast('No other folders to move to', 'error'); return; }
            const list = targets.map((f, i) => `${i + 1}. ${f}`).join('\n');
            const choice = prompt('Move to:\n' + list + '\n\nEnter number:');
            if (!choice) return;
            const idx = parseInt(choice, 10) - 1;
            if (isNaN(idx) || idx < 0 || idx >= targets.length) { showToast('Invalid selection', 'error'); return; }
            const targetFolder = targets[idx];
            try {
                const record = await DevDB.getFile(fileKey);
                if (!record) { showToast('File not found', 'error'); return; }
                const filename = fileKey.split('/').slice(1).join('/');
                await DevDB.putFile(targetFolder + '/' + filename, record.blob, record.originalName);
                await DevDB.deleteFile(fileKey);
                // Move companion extraction JSON if it exists
                const extKey = fileKey.replace(/\.[^.]+$/, '_extraction.json');
                if (extKey !== fileKey) {
                    const extRecord = await DevDB.getFile(extKey);
                    if (extRecord) {
                        const extFilename = extKey.split('/').slice(1).join('/');
                        await DevDB.putFile(targetFolder + '/' + extFilename, extRecord.blob, extRecord.originalName);
                        await DevDB.deleteFile(extKey);
                    }
                }
                // Refresh caches for both folders
                delete state.expandedDevFolders[currentFolder];
                delete state.expandedDevFolders[targetFolder];
                // Re-expand source folder if it was expanded
                try {
                    const srcFiles = await DevDB.listFiles(currentFolder);
                    state.expandedDevFolders[currentFolder] = srcFiles.filter(f => f.key.split('/').pop() !== '.folder').map(f => ({
                        key: f.key, size: f.size, uploaded: f.uploaded,
                        customMetadata: { originalName: f.originalName }, _local: true
                    }));
                } catch (_) {}
                state.selectedFileKey = null;
                renderFolderTree(state.folders);
                showToast('Moved to ' + targetFolder);
                // Schedule folder summary regeneration for both source and target
                scheduleFolderSummary(currentFolder);
                scheduleFolderSummary(targetFolder);
            } catch (err) {
                console.error('Move failed:', err);
                showToast('Move failed', 'error');
            }
        }

        async function createDevFolder() {
            const folderName = prompt('New folder name:');
            if (!folderName) return;
            if (folderName.includes('/')) { showToast('Folder name cannot contain "/"', 'error'); return; }
            if (state.devFolders.includes(folderName)) { showToast('Folder already exists', 'error'); return; }
            try {
                await DevDB.putFile(folderName + '/.folder', new Blob(['']), '.folder');
                await loadDevFolders();
                renderFolderTree(state.folders);
                showToast('Created folder: ' + folderName);
            } catch (err) {
                console.error('Create folder failed:', err);
                showToast('Create folder failed', 'error');
            }
        }

        async function deleteDevFolder(folderName) {
            try {
                const files = await DevDB.listFiles(folderName);
                const realFiles = files.filter(f => f.key.split('/').pop() !== '.folder');
                if (realFiles.length > 0) { showToast('Folder is not empty', 'error'); return; }
                if (!confirm('Delete folder "' + folderName + '"?')) return;
                // Delete sentinel
                const sentinel = files.find(f => f.key.split('/').pop() === '.folder');
                if (sentinel) await DevDB.deleteFile(sentinel.key);
                delete state.expandedDevFolders[folderName];
                if (state.currentPath[1] === folderName) {
                    state.currentPath = ['Development'];
                }
                await loadDevFolders();
                renderFolderTree(state.folders);
                showToast('Deleted folder: ' + folderName);
            } catch (err) {
                console.error('Delete folder failed:', err);
                showToast('Delete folder failed', 'error');
            }
        }

        function showToast(message, type = 'success') {
            elements.toastMessage.textContent = message;
            elements.toast.className = `toast ${type}`;
            elements.toast.classList.add('show');

            setTimeout(() => {
                elements.toast.classList.remove('show');
            }, 3000);
        }

        // ============================================
        // Search
        // ============================================
        let searchInProgress = false;

        async function runSearch() {
            const input = document.getElementById('searchInput');
            const query = input.value.trim();
            if (!query || searchInProgress) return;

            if (!settings.openaiKey) {
                showToast('OpenAI API key required for search. Add it in Settings.', 'error');
                return;
            }

            searchInProgress = true;
            document.getElementById('searchBtn').disabled = true;

            // Reset progress
            const progress = document.getElementById('searchProgress');
            progress.classList.add('active');
            document.getElementById('searchStage1').className = 'search-stage';
            document.getElementById('searchStage2').className = 'search-stage';
            document.getElementById('searchStage3').className = 'search-stage';

            try {
                const result = await Search.search(query, (p) => {
                    document.getElementById('searchProgressText').textContent = p.message;
                    if (p.stage >= 1) document.getElementById('searchStage1').className = 'search-stage ' + (p.stage > 1 ? 'done' : 'active');
                    if (p.stage >= 2) document.getElementById('searchStage2').className = 'search-stage ' + (p.stage > 2 ? 'done' : 'active');
                    if (p.stage >= 3) document.getElementById('searchStage3').className = 'search-stage ' + (p.done ? 'done' : 'active');
                });

                renderSearchResults(result);
            } catch (err) {
                console.error('[Search] Error:', err);
                showToast('Search failed: ' + err.message, 'error');
                document.getElementById('searchResults').innerHTML = `
                    <div class="search-empty">
                        <p style="color: var(--error);">Search failed: ${err.message}</p>
                    </div>`;
            } finally {
                searchInProgress = false;
                document.getElementById('searchBtn').disabled = false;
                setTimeout(() => progress.classList.remove('active'), 2000);
            }
        }

        function renderSearchResults(result) {
            const container = document.getElementById('searchResults');

            if (result.results.length === 0) {
                container.innerHTML = `
                    <div class="search-empty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"/>
                            <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                        </svg>
                        <p>No relevant results found. Try a different query or make sure your documents have been extracted.</p>
                    </div>`;
                return;
            }

            let html = `<div class="search-summary">
                Found ${result.results.length} result${result.results.length !== 1 ? 's' : ''} across
                ${result.files.length} file${result.files.length !== 1 ? 's' : ''} in
                ${result.folders.length} folder${result.folders.length !== 1 ? 's' : ''}
                (${(result.elapsed / 1000).toFixed(1)}s)
            </div>`;

            for (const item of result.results) {
                html += renderSearchResultCard(item);
            }

            container.innerHTML = html;
        }

        function renderSearchResultCard(item) {
            const badgeClass = item.type === 'table' ? 'table'
                : item.type === 'chart' ? 'chart'
                : item.type === 'image' ? 'image'
                : item.type === 'reading' ? 'reading'
                : '';

            let contentHtml = '';

            if (item.type === 'section' && item.content) {
                contentHtml = `<h4>${escapeHtml(item.content.heading || '')}</h4>
                    <p>${escapeHtml(truncateText(item.content.text || '', 500))}</p>`;
            } else if (item.type === 'table' && item.content) {
                contentHtml = `<h4>${escapeHtml(item.content.title || 'Table')}</h4>`;
                if (item.content.headers && item.content.rows) {
                    contentHtml += `<table class="search-result-table"><thead><tr>`;
                    for (const h of item.content.headers) {
                        contentHtml += `<th>${escapeHtml(h)}</th>`;
                    }
                    contentHtml += `</tr></thead><tbody>`;
                    const maxRows = Math.min(item.content.rows.length, 10);
                    for (let i = 0; i < maxRows; i++) {
                        contentHtml += `<tr>`;
                        for (const cell of item.content.rows[i]) {
                            contentHtml += `<td>${escapeHtml(String(cell))}</td>`;
                        }
                        contentHtml += `</tr>`;
                    }
                    if (item.content.rows.length > 10) {
                        contentHtml += `<tr><td colspan="${item.content.headers.length}" style="text-align:center; color:var(--text-secondary); font-style:italic;">... ${item.content.rows.length - 10} more rows</td></tr>`;
                    }
                    contentHtml += `</tbody></table>`;
                }
            } else if (item.type === 'chart' && item.content) {
                contentHtml = `<h4>${escapeHtml(item.content.title || 'Chart')} (${escapeHtml(item.content.type || '')})</h4>`;
                if (item.content.insights) {
                    contentHtml += `<p>${escapeHtml(item.content.insights)}</p>`;
                }
                if (item.content.data) {
                    contentHtml += `<pre>${escapeHtml(JSON.stringify(item.content.data, null, 2))}</pre>`;
                }
            } else if (item.type === 'image' && item.content) {
                contentHtml = `<p>${escapeHtml(item.content.description || '')}</p>`;
                if (item.content.ocr_text) {
                    contentHtml += `<pre>${escapeHtml(item.content.ocr_text)}</pre>`;
                }
            } else if (item.type === 'reading' && item.content) {
                contentHtml = `<div class="search-reading-card">
                    <span class="search-reading-param">${escapeHtml(item.content.parameter || '')}</span>
                    <span class="search-reading-value">${escapeHtml(String(item.content.value || ''))}</span>
                    <span class="search-reading-unit">${escapeHtml(item.content.unit || '')}</span>
                </div>`;
            }

            return `<div class="search-result-card">
                <div class="search-result-header">
                    <span class="search-result-file">${escapeHtml(item.fileTitle || item.filename || '')}</span>
                    <span class="search-type-badge ${badgeClass}">${item.type}</span>
                    <span style="font-size:0.7rem; color:var(--text-secondary);">${escapeHtml(item.folder || '')}</span>
                </div>
                <div class="search-result-reason">${escapeHtml(item.reason || '')}</div>
                <div class="search-result-content">${contentHtml}</div>
            </div>`;
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function truncateText(text, maxLen) {
            if (text.length <= maxLen) return text;
            return text.substring(0, maxLen) + '...';
        }

        // ============================================
        // Event Listeners
        // ============================================
        function setupEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab));
            });

            // Logo click for settings (triple click)
            let clickCount = 0;
            let clickTimer = null;
            document.getElementById('logo').addEventListener('click', () => {
                clickCount++;
                if (clickCount === 3) {
                    openSettings();
                    clickCount = 0;
                }
                clearTimeout(clickTimer);
                clickTimer = setTimeout(() => clickCount = 0, 500);
            });

            // Mobile sidebar toggle
            const sidebarEl = document.getElementById('sidebar');
            const sidebarOverlay = document.getElementById('sidebarOverlay');
            const openSidebar = () => { sidebarEl.classList.add('open'); sidebarOverlay.classList.add('open'); };
            const closeSidebar = () => { sidebarEl.classList.remove('open'); sidebarOverlay.classList.remove('open'); };
            document.getElementById('sidebarToggle').addEventListener('click', openSidebar);
            document.getElementById('sidebarClose').addEventListener('click', closeSidebar);
            sidebarOverlay.addEventListener('click', closeSidebar);

            // Refresh button
            document.getElementById('refreshBtn').addEventListener('click', () => {
                loadFiles(state.currentPath);
                showToast('Refreshed', 'success');
            });

            // Gallery filter
            elements.galleryDateFilter.addEventListener('change', (e) => {
                const date = e.target.value;
                const filtered = date
                    ? state.galleryImages.filter(img => img.key.startsWith(date + '/'))
                    : state.galleryImages;
                renderGallery(filtered);
            });

            // Preview modal
            document.getElementById('previewClose').addEventListener('click', closePreview);
            document.getElementById('previewDownload').addEventListener('click', downloadFile);
            elements.previewModal.addEventListener('click', (e) => {
                if (e.target === elements.previewModal) closePreview();
            });

            // Settings modal
            document.getElementById('settingsClose').addEventListener('click', closeSettings);
            document.getElementById('saveSettings').addEventListener('click', saveSettings);
            elements.settingsModal.addEventListener('click', (e) => {
                if (e.target === elements.settingsModal) closeSettings();
            });

            // Search
            document.getElementById('searchBtn').addEventListener('click', runSearch);
            document.getElementById('searchInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') runSearch();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closePreview();
                    closeSettings();
                }
            });

            // Visibility change - pause/resume polling
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    stopPolling();
                } else {
                    startPolling();
                }
            });
        }

        // ============================================
        // Initialization
        // ============================================
        async function init() {
            setupEventListeners();

            // Initialize local Development DB
            await DevDB.open();
            await loadDevFolders();

            // Check if settings are configured
            if (!settings.apiEndpoint || !settings.apiKey) {
                setConnectionStatus(false);
                elements.statusText.textContent = 'Not configured';
                openSettings();
                return;
            }

            // Check connection
            const connected = await checkConnection();

            if (connected) {
                await loadFolderTree();
                await loadFiles([]);
                startPolling();

                // Initial sync: check all R2 files and sync any new ones to Development
                try {
                    const data = await api('/list');
                    const allFiles = (data.objects || []).filter(obj => !obj.key.endsWith('_metadata.json'));
                    syncNewFilesToDev(allFiles);
                } catch (err) {
                    console.warn('[Dev Sync] Initial sync failed:', err);
                }
            }

            // Startup stale-check for folder summaries (after initial sync settles)
            setTimeout(async () => {
                try {
                    const devFolders = await DevDB.listSubfolders();
                    for (const folder of devFolders) {
                        if (folder === 'Uncategorized') continue;
                        scheduleFolderSummary(folder);
                    }
                } catch (err) {
                    console.warn('[Folder Summary] Startup stale-check failed:', err);
                }
            }, 15000);
        }

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(console.error);
        }

        // Start app
        init();
    </script>
</body>

</html>